#!/usr/bin/env node

/**
 * Script to synchronize buildInfo.json from root to frontend
 * Ensures both files stay in sync for consistent version display
 * PRESERVES the detailed frontend format while updating key fields
 *
 * Usage:
 *   npm run sync:buildinfo
 *
 * Or add to your build process:
 *   npm run build && npm run sync:buildinfo
 */

const fs = require('fs');
const path = require('path');

// File paths
const rootBuildInfo = path.join(__dirname, '..', 'buildInfo.json');
const frontendBuildInfo = path.join(__dirname, '..', 'frontend', 'src', 'buildInfo.json');

function syncBuildInfo() {
  try {
    // Check if root buildInfo exists
    if (!fs.existsSync(rootBuildInfo)) {
      console.error('❌ Root buildInfo.json not found at:', rootBuildInfo);
      process.exit(1);
    }

    // Read root buildInfo
    const rootContent = fs.readFileSync(rootBuildInfo, 'utf8');
    let rootData;

    // Parse root JSON
    try {
      rootData = JSON.parse(rootContent);
    } catch (parseError) {
      console.error('❌ Root buildInfo.json contains invalid JSON:', parseError.message);
      process.exit(1);
    }

    // Check if frontend buildInfo exists and has detailed format
    let frontendData;
    if (fs.existsSync(frontendBuildInfo)) {
      try {
        const frontendContent = fs.readFileSync(frontendBuildInfo, 'utf8');
        frontendData = JSON.parse(frontendContent);
      } catch (e) {
        // If can't parse frontend, use root as base
        frontendData = rootData;
      }
    } else {
      // If frontend doesn't exist, use root as base
      frontendData = rootData;
    }

    // Sync key fields from root to frontend while preserving detailed format
    // Only update the fields that should come from root
    frontendData.version = rootData.version;
    frontendData.releaseDate = rootData.releaseDate;
    frontendData.buildStatus = rootData.buildStatus;
    frontendData.testsStatus = rootData.testsStatus;

    // Update sprint and phase info if present in root
    if (rootData.sprint) frontendData.sprint = rootData.sprint;
    if (rootData.phases) frontendData.phases = rootData.phases;
    if (rootData.totalDuration) frontendData.totalDuration = rootData.totalDuration;
    if (rootData.newFeatures) frontendData.newFeatures = rootData.newFeatures;
    if (rootData.databaseTables) frontendData.databaseTables = rootData.databaseTables;
    if (rootData.techStack) frontendData.techStack = rootData.techStack;
    if (rootData.improvements) frontendData.improvements = rootData.improvements;
    if (rootData.upcomingFeatures) frontendData.upcomingFeatures = rootData.upcomingFeatures;
    if (rootData.notes) frontendData.notes = rootData.notes;

    // Preserve frontend-specific fields (buildDate, git, latestDoneFeatures, futureTodos, lastSession)
    // These are generated by generate-build-info.js or maintained in frontend

    // Write updated frontend buildInfo
    fs.writeFileSync(frontendBuildInfo, JSON.stringify(frontendData, null, 2), 'utf8');

    console.log('✅ BuildInfo synchronized successfully!');
    console.log(`   Version: ${frontendData.version}`);
    console.log(`   Date: ${frontendData.buildDate || frontendData.releaseDate || new Date().toISOString()}`);
    console.log(`   Root: ${rootBuildInfo}`);
    console.log(`   Frontend: ${frontendBuildInfo}`);
    console.log(`   Format: ${frontendData.latestDoneFeatures ? 'Detailed (preserved)' : 'Simple'}`);

  } catch (error) {
    console.error('❌ Error syncing buildInfo:', error.message);
    process.exit(1);
  }
}

// Run the sync
syncBuildInfo();